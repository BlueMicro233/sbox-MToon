//=========================================================================================================================
// Optional
//=========================================================================================================================
HEADER
{
    Description = "Toon Shader with Global Illumination";
    Version = 3.9;
}

//=========================================================================================================================
// Optional
//=========================================================================================================================
FEATURES
{
    #include "common/features.hlsl"
}

//=========================================================================================================================
COMMON
{
    #include "common/shared.hlsl"
}

//=========================================================================================================================

struct VertexInput
{
    #include "common/vertexinput.hlsl"
};

//=========================================================================================================================

struct PixelInput
{
    #include "common/pixelinput.hlsl"
};

//=========================================================================================================================

VS
{
    #include "common/vertex.hlsl"
    //
    // Main
    //
    PixelInput MainVs(INSTANCED_SHADER_PARAMS(VertexInput i))
    {
        PixelInput o = ProcessVertex(i);
        // Add your vertex manipulation functions here
        return FinalizeVertex(o);
    }
}

//=========================================================================================================================

PS
{
    #include "common/pixel.hlsl"

    RenderState(CullMode, F_RENDER_BACKFACES ? NONE : DEFAULT);

    // #define MTOON_DEBUG_NORMAL
    // #define MTOON_DEBUG_LITSHADERATE
    #define _NORMALMAP
    #define _ALPHATEST_ON
    #define _ALPHABLEND_ON

    SamplerState MeshTextureSampler < Filter(MIN_MAG_MIP_LINEAR); AddressU(WRAP); AddressV(WRAP); >;

    //
    // Main
    //
    CreateInputTexture2D(InputMainTex, Srgb, 8, "", "", "MToon Color,0/Texture,10/1", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(MainTex)< Channel(RGBA, Box(InputMainTex), Srgb); OutputFormat(BC7); SrgbRead(true); >;

    float4 Color < UiType(Color); Default4(1.0, 1.0, 1.0, 1.0); UiGroup("MToon Color,0/Texture,10/2"); >;

    CreateInputTexture2D(InputShadeTexture, Srgb, 8, "", "", "MToon Color,0/Texture,10/3", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(ShadeTexture)< Channel(RGBA, Box(InputShadeTexture), Srgb); OutputFormat(BC7); SrgbRead(true); >;

    float4 ShadeColor < UiType(Color); Default4(0.97, 0.81, 0.86, 1.0); UiGroup("MToon Color,0/Texture,10/4"); >;
    float Cutoff < UiType(Slider); Range(0.0, 1.0); Default1(0.5); UiGroup("MToon Color,0/Alpha,20/1"); >;

    float ShadeToony < UiType(Slider); Range(0.0, 1.0); Default1(0.9); UiGroup("MToon Lighting,1/1"); >;

    // CreateInputTexture2D(InputBumpMap, Linear, 8, "", "", "MToon Lighting,1/2", Default4(0.5, 0.5, 1.0, 0.5));
    // CreateTexture2DWithoutSampler(BumpMap)< Channel(RGBA, Box(InputBumpMap), Linear); OutputFormat(BC7); SrgbRead(false); >;

    float ShadeShift < UiType(Slider); Range(-1.0, 1.0); Default1(0.0); UiGroup("MToon Lighting,11/Advanced Settings,20/1"); >;

    CreateInputTexture2D(InputShadingGradeTexture, Srgb, 8, "", "", "MToon Lighting,1/Advanced Settings,20/2", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(ShadingGradeTexture)< Channel(RGBA, Box(InputShadingGradeTexture), Srgb); OutputFormat(BC7); SrgbRead(true); >;

    float ShadingGradeRate < UiType(Slider); Range(0.0, 1.0); Default1(1.0); UiGroup("MToon Lighting,1/Advanced Settings,20/3"); >;

    float LightColorAttenuation < UiType(Slider); Range(0.0, 1.0); Default1(0.0); UiGroup("MToon Lighting,1/Advanced Settings,20/4"); >;

    float IndirectLightIntensity < UiType(Slider); Range(0.0, 1.0); Default1(0.1); UiGroup("MToon Lighting,1/Advanced Settings,20/5"); >;

    // Texture2D _RimTexture;
    // float4 _RimColor;
    // float _RimLightingMix;
    // float _RimFresnelPower;
    // float _RimLift;
    // Texture2D _SphereAdd;

    float4 EmissionColor < UiType(Color); Default4(0.0, 0.0, 0.0, 1.0); UiGroup("MToon Emission,2/1"); >;
    CreateInputTexture2D(InputEmissionMap, Srgb, 8, "", "", "MToon Emission,2/2", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(EmissionMap)< Channel(RGBA, Box(InputEmissionMap), Srgb); OutputFormat(BC7); SrgbRead(true); >;

    // const
    static const float PI_2 = 6.28318530718;
    static const float EPS_COL = 0.00001;

    class MToonShadingModel : ShadingModel
    {
        float2 mainUv;
        float4 mainTex;
        float alpha;
        float3 worldNormal;
        float3 worldView;
        float4 lit;
        float4 shade;
        float shadingGrade;
        float3 lighting;
        float3 flColor;

        //
        // Consumes a material and converts it to the internal shading parameters,
        // That is more easily consumed by the shader.
        //
        // Inherited classes can expand this to whichever shading model they want.
        //
        void Init(const PixelInput i, const Material m)
        {
            // uv
            mainUv = i.vTextureCoords.xy;
            
            // main tex
            mainTex = MainTex.Sample(MeshTextureSampler, mainUv);
        
            // alpha
            alpha = 1;
#ifdef _ALPHATEST_ON
            alpha = Color.a * mainTex.a;
            alpha = (alpha - Cutoff) / max(fwidth(alpha), EPS_COL) + 0.5; // Alpha to Coverage
            clip(alpha - Cutoff);
            alpha = 1.0; // Discarded, otherwise it should be assumed to have full opacity
#endif
#ifdef _ALPHABLEND_ON
            alpha = Color.a * mainTex.a;
#endif

            // normal
            worldNormal = m.Normal;

//          // normal
//          float3 tspace0 = float3(i.vTangentUWs.x, i.vTangentVWs.x, i.vNormalWs.x);
//          float3 tspace1 = float3(i.vTangentUWs.y, i.vTangentVWs.y, i.vNormalWs.y);
//          float3 tspace2 = float3(i.vTangentUWs.z, i.vTangentVWs.z, i.vNormalWs.z);
// #ifdef _NORMALMAP
//          half3 tangentNormal = BumpMap.Sample(MeshTextureSampler, mainUv).xyz;
//          worldNormal.x = dot(tspace0, tangentNormal);
//          worldNormal.y = dot(tspace1, tangentNormal);
//          worldNormal.z = dot(tspace2, tangentNormal);
// #else
//          worldNormal = half3(tspace0.z, tspace1.z, tspace2.z);
// #endif
//          // unity_OrthoParams.w -> 1.0 is orthographic / 0.0 is perspective
//          float3 worldView = normalize(lerp(g_vCameraPositionWs - i.vPositionWithOffsetWs, g_matWorldToView[2].xyz, unity_OrthoParams.w));
//          worldNormal *= step(0, dot(worldView, worldNormal)) * 2 - 1; // flip if projection matrix is flipped
//          // worldNormal *= lerp(+1.0, -1.0, i.isOutline);
//          worldNormal = normalize(worldNormal);


            lit = Color * mainTex;
            flColor = 0.0f;

            shadingGrade = 1.0 - ShadingGradeRate * (1.0 - ShadingGradeTexture.Sample(MeshTextureSampler, mainUv).r);
            shade = ShadeColor * ShadeTexture.Sample(MeshTextureSampler, mainUv);
        }
        
        //
        // Executed for every direct light
        //
        LightShade Direct(const LightData light)
        {
            // Shading output
            LightShade lightShade;

            // Decide albedo color rate from Direct Light
            float lightIntensity = light.NdotL; // [0, 1]
            lightIntensity = lightIntensity * light.Visibility * light.Attenuation; // receive shadow
            lightIntensity = lightIntensity * shadingGrade; // darker
            // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]
            float maxIntensityThreshold = lerp(1, ShadeShift, ShadeToony);
            float minIntensityThreshold = ShadeShift;
            lightIntensity = saturate((lightIntensity - minIntensityThreshold) / max(EPS_COL, (maxIntensityThreshold - minIntensityThreshold)));
            
            // Albedo color
            lightShade.Diffuse = lerp(shade.rgb, lit.rgb, lightIntensity);

            float3 lightColor = saturate(light.Visibility * light.Attenuation * light.Color);
            // Direct Light
            lighting = lightColor;
            lighting = lerp(lighting, max(EPS_COL, max(lighting.x, max(lighting.y, lighting.z))), LightColorAttenuation); // color atten
            // base light does not darken.
            lightShade.Diffuse *= lighting;

            // No specular
            lightShade.Specular = 0.0f;

            return lightShade;
        }
        
        //
        // Executed for indirect lighting, combine ambient occlusion, etc.
        //
        LightShade Indirect()
        {
            LightShade lightShade;

            // Get a flat average ambient
            float3 vAmbientCube[6];
            SampleLightProbeVolume(vAmbientCube, float3(0,0,0));

            // Light with our ambient color
            for(int i = 0; i < 6; i++)
                flColor += vAmbientCube[i] * (1.0f / 6.0f);
            
            float3 indirectLighting = lerp(flColor, 1.0, IndirectLightIntensity);
            indirectLighting = lerp(indirectLighting, max(EPS_COL, max(indirectLighting.x, max(indirectLighting.y, indirectLighting.z))), LightColorAttenuation); // color atten
            lightShade.Diffuse = indirectLighting * lit.xyz;

            lightShade.Diffuse = min(lightShade.Diffuse, lit.xyz); // comment out if you want to PBR absolutely.

            // No specular
            lightShade.Specular = 0.0f;

            return lightShade;
        }

        float4 PostProcess(float4 vColor)
        {
            // // parametric rim lighting
            // float3 staticRimLighting = 1;
            // float3 mixedRimLighting = lighting + flColor;
            // float3 rimLighting = lerp(staticRimLighting, mixedRimLighting, _RimLightingMix);
            // float3 rim = pow(saturate(1.0 - dot(worldNormal, worldView) + _RimLift), max(_RimFresnelPower, EPS_COL)) * _RimColor.rgb * tex2D(_RimTexture, mainUv).rgb;
            // // i.isOutline -> 0 when outline is disabled, 1 when outline is enabled.
            // vColor += lerp(rim * rimLighting, float3(0, 0, 0), i.isOutline);

            // // additive matcap
            // float3 worldCameraUp = normalize(g_matWorldToView[1].xyz);
            // float3 worldViewUp = normalize(worldCameraUp - worldView * dot(worldView, worldCameraUp));
            // float3 worldViewRight = normalize(cross(worldView, worldViewUp));
            // float2 matcapUv = float2(dot(worldViewRight, worldNormal), dot(worldViewUp, worldNormal)) * 0.5 + 0.5;
            // float3 matcapLighting = tex2D(_SphereAdd, matcapUv);
            // // i.isOutline -> 0 when outline is disabled, 1 when outline is enabled.
            // vColor += lerp(matcapLighting, float3(0, 0, 0), i.isOutline);

            // Emission
            float3 emission = EmissionMap.Sample(MeshTextureSampler, mainUv).rgb * EmissionColor.rgb;
            // i.isOutline -> 0 when outline is disabled, 1 when outline is enabled.
            // vColor.xyz += lerp(emission, float3(0, 0, 0), i.isOutline);
            vColor.xyz += emission;

            // debug
#ifdef MTOON_DEBUG_NORMAL
    #ifdef MTOON_FORWARD_ADD
            return float4(0, 0, 0, 0);
    #else
            return float4(worldNormal * 0.5 + 0.5, alpha);
    #endif
#elif MTOON_DEBUG_LITSHADERATE
    #ifdef MTOON_FORWARD_ADD
            return float4(0, 0, 0, 0);
    #else
            return float4(lightIntensity * lighting, alpha);
    #endif
#endif

            float4 result = float4(vColor.xyz, alpha);
            return result;
        }
    };


    float4 MainPs(PixelInput i) : SV_Target0
    {
        Material m = GatherMaterial(i);
        MToonShadingModel sm;
        return FinalizePixelMaterial(i, m, sm);
    }
}
