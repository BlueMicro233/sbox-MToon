//=========================================================================================================================
// Optional
//=========================================================================================================================
HEADER
{
    Description = "Toon Shader with Global Illumination";
    Version = 3.9;
}

//=========================================================================================================================
// Optional
//=========================================================================================================================
FEATURES
{
    Feature(F_USE_NORMAL_MAP, 0..1, "MToon Lighting");
    #include "common/features.hlsl"
    Feature(F_RENDERING_TYPE, 0..3(0="Opaque", 1="Cutout", 2="Transparent", 3="TransparentWithZWrite"), "Rendering");
    Feature(F_PREPASS_ALPHA_TEST, 0..1, "Rendering");
    FeatureRule(Requires1(F_PREPASS_ALPHA_TEST, F_RENDERING_TYPE == 1), "Requires cutout");
    Feature(F_DEBUGGING_OPTIONS, 0..2(0="None", 1="Normal", 2="LitShadeRate"), "MToon Debug");
}

//=========================================================================================================================
COMMON
{
    #include "common/shared.hlsl"
    #define CULL_MODE_ALREADY_SET
    #define DEPTH_STATE_ALREADY_SET
}

//=========================================================================================================================

struct VertexInput
{
    #include "common/vertexinput.hlsl"
};

//=========================================================================================================================

struct PixelInput
{
    #include "common/pixelinput.hlsl"
};

//=========================================================================================================================

VS
{
    #include "common/vertex.hlsl"
    //
    // Main
    //
    PixelInput MainVs(INSTANCED_SHADER_PARAMS(VertexInput i))
    {
        PixelInput o = ProcessVertex(i);
        // Add your vertex manipulation functions here
        return FinalizeVertex(o);
    }
}

//=========================================================================================================================

PS
{
    //
    // Combos
    //
    StaticCombo(S_USE_NORMAL_MAP, F_USE_NORMAL_MAP, Sys(ALL));
    StaticCombo(S_RENDERING_TYPE, F_RENDERING_TYPE, Sys(ALL));
    StaticCombo(S_DEBUGGING_OPTIONS, F_DEBUGGING_OPTIONS, Sys(ALL));

    RenderState(CullMode, F_RENDER_BACKFACES ? NONE : DEFAULT);

    RenderState(DepthEnable, true);
    RenderState(DepthFunc, LESS_EQUAL);

    #if S_RENDERING_TYPE == 1 // Cutout
        #define S_ALPHA_TEST 1
        RenderState(DepthWriteEnable, true);
    #elif S_RENDERING_TYPE == 2 // Transparent
        #define S_TRANSLUCENT 1
        RenderState(DepthWriteEnable, false);
    #elif S_RENDERING_TYPE == 3 // TransparentWithZWrite
        #define S_TRANSLUCENT 1
        RenderState(DepthWriteEnable, true);
    #else // Opaque
        RenderState(DepthWriteEnable, true);
    #endif

    //
    // Includes
    //
    #include "common/pixel.hlsl"

    // Override Material Helper to support Alpha channel
    float4 MToonSurfaceShading(PixelInput i, Material m, ShadingModel sm)
    {
        // Initialize our shading model.
        // Converts material inputs into parameters that are more easily consumed by the shader.
        sm.Init(i, m);

        // Get the lighting contribution from the dynamic direct lights
        LightShade shade = DynamicLight::GetLighting(i, m, sm);
        
        // Get the lighting contribution from the static direct lights
        shade = SumLightShades(shade, StaticLight::GetLighting(i, m, sm));

        // Get the lighting contribution from the indirect lighting ( ambient and cubemaps )
        shade = SumLightShades(shade, IndirectLight::GetLighting(i, m, sm));

        // Post process and return
        return sm.PostProcess(float4(shade.Diffuse + shade.Specular, 1.0f)).rgba;
    }

    //-----------------------------------------------------------------------------
    //
    // Compose the final color with lighting from material parameters
    //
    //-----------------------------------------------------------------------------

    float4 MToonFinalizePixelMaterial(PixelInput i, Material m, ShadingModel sm)
    {    
        float4 vColor = float4(MToonSurfaceShading(i, m, sm));

        #if(S_MODE_TOOLS_VIS)
            float3 vPositionWs = i.vPositionWithOffsetWs.xyz + g_vCameraPositionWs;

            ToolsVisInitColor(vColor.rgba);

            ToolsVisHandleFlatOverlayColor(m.Albedo.rgb, vColor.rgba);
            ToolsVisHandleFullbright(vColor.rgba, m.Albedo.rgb, vPositionWs.xyz, i.vNormalWs.xyz);

            #if(!S_UNLIT)
                [flatten]
                if (g_nToolsVisMode == TOOLS_VIS_MODE_DIFFUSE_LIGHTING || 
                    g_nToolsVisMode == TOOLS_VIS_MODE_SPECULAR_LIGHTING || 
                    g_nToolsVisMode == TOOLS_VIS_MODE_DIFFUSE_AMBIENT_OCCLUSION ||
                    g_nToolsVisMode == TOOLS_VIS_MODE_SPECULAR_AMBIENT_OCCLUSION)
                {
                    LightShade shade = DynamicLight::GetLighting(i, m, sm);
                    shade = SumLightShades(shade, StaticLight::GetLighting(i, m, sm));
                    shade = SumLightShades(shade, IndirectLight::GetLighting(i, m, sm));

                    if (g_nToolsVisMode == TOOLS_VIS_MODE_DIFFUSE_LIGHTING)
                    {
                        vColor.rgb = shade.Diffuse * 0.5f * g_flToneMapScalarLinear;
                    }
                    else if(g_nToolsVisMode == TOOLS_VIS_MODE_SPECULAR_LIGHTING)
                    {
                        vColor.rgb = shade.Specular * g_flToneMapScalarLinear;
                    }
                    else if(g_nToolsVisMode == TOOLS_VIS_MODE_DIFFUSE_AMBIENT_OCCLUSION)
                    {
                        vColor.rgb = shade.Diffuse * m.AmbientOcclusion.rgb;
                    }
                    else if(g_nToolsVisMode == TOOLS_VIS_MODE_SPECULAR_AMBIENT_OCCLUSION)
                    {
                        vColor.rgb = shade.Specular * m.AmbientOcclusion.rgb;
                    }
                }
            #endif

            [flatten]
            if (g_nToolsVisMode == TOOLS_VIS_MODE_TRANSMISSIVE_LIGHTING)
            {
                vColor.rgb = m.Transmission * g_flToneMapScalarLinear;
            }

            // TODO: ToolsVisHandleLightingComplexity(vColor.rgba, lightingTerms);

            ToolsVisHandleAlbedo(vColor.rgba, m.Albedo.rgb);
            ToolsVisHandleReflectivity(vColor.rgba, m.Albedo.rgb);
            ToolsVisHandleRoughness(vColor.rgba, float2(m.Roughness, m.Metalness));
            ToolsVisHandleShaderIDColor(vColor.rgba);
            // TODO: ToolsVisHandleCubemapReflections(vColor.rgba, lightingTerms);

            ToolsVisHandleNormalWs(vColor.rgba, m.Normal.xyz);
            ToolsVisHandleTangentUWs(vColor.rgba, i.vTangentUWs.xyz);
            ToolsVisHandleTangentVWs(vColor.rgba, i.vTangentVWs.xyz);
            ToolsVisHandleGeometricNormalWs(vColor.rgba, normalize(i.vNormalWs.xyz));

            #ifdef COMMON_PIXEL_MATERIAL_INPUTS_H
            #ifndef S_MULTIBLEND
                ToolsVisShowUVs(vColor.rgba, m.Albedo.rgb, g_tColor, i.vTextureCoords.xy);
                ToolsVisShowMipUtilization(vColor.rgba, m.Albedo.rgb, g_tColor, i.vTextureCoords.xy);
            #endif
            #endif

            if (g_nToolsVisMode != 0)
            {
                vColor.rgb = saturate(vColor.rgb); // turns off bloom in tools vis mode
            }

        #endif
        
        return vColor;
    }

    float4 MToonFinalizePixelMaterial(PixelInput i, Material m)
    {
        //
        // If not defined, use the default shading model
        // Keeps compatiblity with the old code
        //
        ShadingModelStandard sm;
        
        return FinalizePixelMaterial(i, m, sm);
    }

    //
    // Main
    //
    CreateInputTexture2D(InputLitTexture, Srgb, 8, "", "", "MToon Color,1/Texture,1/1", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(LitTexture)< Channel(RGBA, Box(InputLitTexture), Srgb); OutputFormat(BC7); SrgbRead(true); >;
    float4 LitColor < UiType(Color); Default4(1.0, 1.0, 1.0, 1.0); UiGroup("MToon Color,1/Texture,1/2"); >;
    CreateInputTexture2D(InputShadeTexture, Srgb, 8, "", "", "MToon Color,1/Texture,1/3", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(ShadeTexture)< Channel(RGBA, Box(InputShadeTexture), Srgb); OutputFormat(BC7); SrgbRead(true); >;
    float4 ShadeColor < UiType(Color); Default4(0.97, 0.81, 0.86, 1.0); UiGroup("MToon Color,1/Texture,1/4"); >;

    #if S_ALPHA_TEST
        float Cutoff < UiType(Slider); Range(0.0, 1.0); Default1(0.5); UiGroup("MToon Color,1/Alpha,2/1"); >;
    #endif

    float ShadingToony < UiType(Slider); Range(0.0, 1.0); Default1(0.9); UiGroup("MToon Lighting,2/1"); >;

    float ShadingShift < UiType(Slider); Range(-1.0, 1.0); Default1(0.0); UiGroup("MToon Lighting,2/Advanced Settings,2/1"); >;
    CreateInputTexture2D(InputShadingGradeTexture, Srgb, 8, "", "", "MToon Lighting,2/Advanced Settings,2/2", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(ShadingGradeTexture)< Channel(RGBA, Box(InputShadingGradeTexture), Srgb); OutputFormat(BC7); SrgbRead(true); >;
    float ShadingGradeRate < UiType(Slider); Range(0.0, 1.0); Default1(1.0); UiGroup("MToon Lighting,2/Advanced Settings,2/3"); >;
    float LightColorAttenuation < UiType(Slider); Range(0.0, 1.0); Default1(0.0); UiGroup("MToon Lighting,2/Advanced Settings,2/4"); >;
    float IndirectLightIntensity < UiType(Slider); Range(0.0, 1.0); Default1(0.0); UiGroup("MToon Lighting,2/Advanced Settings,2/5"); >;

    CreateInputTexture2D(InputEmissionMap, Srgb, 8, "", "", "MToon Emission,3/1", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(EmissionMap)< Channel(RGBA, Box(InputEmissionMap), Srgb); OutputFormat(BC7); SrgbRead(true); >;
    float4 EmissionColor < UiType(Color); Default4(0.0, 0.0, 0.0, 1.0); UiGroup("MToon Emission,3/2"); >;
    CreateInputTexture2D(InputMatCap, Srgb, 8, "", "", "MToon Emission,3/3", Default4(0.0, 0.0, 0.0, 1.0));
    CreateTexture2DWithoutSampler(MatCap)< Channel(RGBA, Box(InputMatCap), Srgb); OutputFormat(BC7); SrgbRead(true); >;

    CreateInputTexture2D(InputRimTexture, Srgb, 8, "", "", "MToon Rim,4/1", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(RimTexture)< Channel(RGBA, Box(InputRimTexture), Srgb); OutputFormat(BC7); SrgbRead(true); >;
    float4 RimColor < UiType(Color); Default4(0.0, 0.0, 0.0, 1.0); UiGroup("MToon Rim,4/2"); >;
    float RimLightingMix < UiType(Slider); Range(0.0, 1.0); Default1(0.0); UiGroup("MToon Rim,4/3"); >;
    float RimFresnelPower < UiType(Slider); Range(0.0, 100.0); Default1(1.0); UiGroup("MToon Rim,4/4"); >;
    float RimLift < UiType(Slider); Range(0.0, 1.0); Default1(0.0); UiGroup("MToon Rim,4/5"); >;

    // const
    static const float PI_2 = 6.28318530718;
    static const float EPS_COL = 0.00001;

    class MToonShadingModel : ShadingModel
    {
        float2 mainUv;
        float4 mainTex;
        float alpha;

        float3 positionWithOffsetWs;
        float3 positionWs;
        float3 viewRayWs;
        float3 normalWs;

        float4 lit;
        float4 shade;
        float shadingGrade;

        float lightIntensity;
        float3 lighting;
        float3 indirectLighting;

        //
        // Consumes a material and converts it to the internal shading parameters,
        // That is more easily consumed by the shader.
        //
        // Inherited classes can expand this to whichever shading model they want.
        //
        void Init(const PixelInput i, const Material m)
        {
            // uv
            mainUv = i.vTextureCoords.xy;
            
            // main tex
            mainTex = Tex2DS(LitTexture, TextureFiltering, mainUv);
        
            // alpha
            alpha = 1;
            #if S_ALPHA_TEST
                alpha = LitColor.a * mainTex.a;
                alpha = (alpha - Cutoff) / max(fwidth(alpha), EPS_COL) + 0.5; // Alpha to Coverage
                clip(alpha - Cutoff);
                alpha = 1.0; // Discarded, otherwise it should be assumed to have full opacity
            #endif
            #if S_TRANSLUCENT
                alpha = LitColor.a * mainTex.a;
                #if !S_ALPHA_TEST // Only enable this on D3D11, where I tested it
                    clip(alpha - 0.0001); // Slightly improves rendering with layered transparency
                #endif
            #endif

            positionWithOffsetWs = i.vPositionWithOffsetWs;
            positionWs = positionWithOffsetWs + g_vCameraPositionWs;

            // View ray in World Space
            viewRayWs = CalculatePositionToCameraDirWs(positionWs);

            // normal
            #if S_USE_NORMAL_MAP
                normalWs = m.Normal;
            #else
                normalWs = float3(i.vNormalWs.x, i.vNormalWs.y, i.vNormalWs.z);
            #endif

            lit = LitColor * mainTex;
            shade = ShadeColor * Tex2DS(ShadeTexture, TextureFiltering, mainUv);
            shadingGrade = 1.0 - ShadingGradeRate * (1.0 - Tex2DS(ShadingGradeTexture, TextureFiltering, mainUv).r);
        }

        //
        // Executed for every direct light
        //
        LightShade Direct(const LightData light)
        {
            // Shading output
            LightShade lightShade;

            float dotNL = dot(light.LightDir, normalWs);

            // Decide albedo color rate from Direct Light
            lightIntensity = dotNL; // [-1, +1]
            lightIntensity = lightIntensity * 0.5 + 0.5; // from [-1, +1] to [0, 1]
            lightIntensity = lightIntensity * light.Visibility * light.Attenuation; // receive shadow
            lightIntensity = lightIntensity * shadingGrade; // darker
            lightIntensity = lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]
            // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]
            float maxIntensityThreshold = lerp(1, ShadingShift, ShadingToony);
            float minIntensityThreshold = ShadingShift;
            lightIntensity = saturate((lightIntensity - minIntensityThreshold) / max(EPS_COL, (maxIntensityThreshold - minIntensityThreshold)));
            
            // Albedo color
            lightShade.Diffuse = lerp(shade.rgb, lit.rgb, lightIntensity);

            float3 lightColor = saturate(light.Visibility * light.Attenuation * light.Color);
            // Direct Light
            lighting = lightColor;
            lighting = lerp(lighting, max(EPS_COL, max(lighting.x, max(lighting.y, lighting.z))), LightColorAttenuation); // color atten
            // base light does not darken.
            lightShade.Diffuse *= lighting;

            // No specular
            lightShade.Specular = 0.0f;

            return lightShade;
        }

        //
        // Executed for indirect lighting, combine ambient occlusion, etc.
        //
        LightShade Indirect()
        {
            LightShade lightShade;
            
            float3 toonedGI = 0.5 * (SampleLightProbeVolume(positionWs, float3(0, 1, 0)) + SampleLightProbeVolume(positionWs, float3(0, -1, 0)));
            indirectLighting = lerp(toonedGI, SampleLightProbeVolume(positionWs, normalWs), IndirectLightIntensity);
            indirectLighting = lerp(indirectLighting, max(EPS_COL, max(indirectLighting.x, max(indirectLighting.y, indirectLighting.z))), LightColorAttenuation); // color atten
            lightShade.Diffuse = indirectLighting * lit.rgb;

            lightShade.Diffuse = min(lightShade.Diffuse, lit.rgb); // comment out if you want to PBR absolutely.

            // No specular
            lightShade.Specular = 0.0f;

            return lightShade;
        }

        float4 PostProcess(float4 vColor)
        {
            // parametric rim lighting
            float3 staticRimLighting = 1;
            float3 mixedRimLighting = lighting + indirectLighting;
            float3 rimLighting = lerp(staticRimLighting, mixedRimLighting, RimLightingMix);
            float3 rim = pow(saturate(1.0 - dot(normalWs, viewRayWs) + RimLift), max(RimFresnelPower, EPS_COL)) * RimColor.rgb * Tex2DS(RimTexture, TextureFiltering, mainUv).rgb;
            vColor.rgb += rim * rimLighting;

            // additive matcap
            float3 worldCameraUp = normalize(g_vCameraUpDirWs);
            float3 worldViewUp = normalize(worldCameraUp - viewRayWs * dot(viewRayWs, worldCameraUp));
            float3 worldViewRight = normalize(cross(viewRayWs, worldViewUp));
            float2 matcapUv = float2(dot(worldViewRight, normalWs), dot(worldViewUp, normalWs)) * 0.5 + 0.5;
            float3 matcapLighting = Tex2DS(MatCap, TextureFiltering, matcapUv).rgb;
            vColor.rgb += matcapLighting;

            // Emission
            float3 emission = Tex2DS(EmissionMap, TextureFiltering, mainUv).rgb * EmissionColor.rgb;
            vColor.rgb += emission;

            // debug
            #if S_DEBUGGING_OPTIONS == 1
                return float4(normalWs * 0.5 + 0.5, alpha);
            #elif S_DEBUGGING_OPTIONS == 2
                return float4(lightIntensity * lighting, alpha);
            #endif

            return float4(vColor.rgb, alpha);
        }
    };

    float4 MainPs(PixelInput i) : SV_Target0
    {
        Material m = GatherMaterial(i);
        MToonShadingModel sm;
        return MToonFinalizePixelMaterial(i, m, sm);
    }
}
