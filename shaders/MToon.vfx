//=========================================================================================================================
// Optional
//=========================================================================================================================
HEADER
{
    Description = "Toon Shader with Global Illumination";
    Version = 3.9;
}

//=========================================================================================================================
// Optional
//=========================================================================================================================
FEATURES
{
    Feature(F_USE_NORMAL_MAP, 0..1, "MToon Lighting");
    #include "common/features.hlsl"
    Feature(F_RENDERING_TYPE, 0..1(0="Opaque", 1="Cutout"), "Rendering");
    Feature(F_DEBUG_NORMAL, 0..1, "MToon Debug");
    Feature(F_DEBUG_LITSHADERATE, 0..1, "MToon Debug");
}

//=========================================================================================================================
COMMON
{
    #include "common/shared.hlsl"
}

//=========================================================================================================================

struct VertexInput
{
    #include "common/vertexinput.hlsl"
};

//=========================================================================================================================

struct PixelInput
{
    #include "common/pixelinput.hlsl"
};

//=========================================================================================================================

VS
{
    #include "common/vertex.hlsl"
    //
    // Main
    //
    PixelInput MainVs(INSTANCED_SHADER_PARAMS(VertexInput i))
    {
        PixelInput o = ProcessVertex(i);
        // Add your vertex manipulation functions here
        return FinalizeVertex(o);
    }
}

//=========================================================================================================================

PS
{
    //
    // Combos
    //
    StaticCombo(S_USE_NORMAL_MAP, F_USE_NORMAL_MAP, Sys(ALL));
    StaticCombo(S_RENDERING_TYPE, F_RENDERING_TYPE, Sys(ALL));
    StaticCombo(S_DEBUG_NORMAL, F_DEBUG_NORMAL, Sys(ALL));
    StaticCombo(S_DEBUG_LITSHADERATE, F_DEBUG_LITSHADERATE, Sys(ALL));

    //
    // Includes
    //
    #include "common/pixel.hlsl"

    RenderState(CullMode, F_RENDER_BACKFACES ? NONE : DEFAULT);

#if S_DEBUG_NORMAL
    #define MTOON_DEBUG_NORMAL
#endif

#if S_DEBUG_LITSHADERATE
    #define MTOON_DEBUG_LITSHADERATE
#endif

#if S_USE_NORMAL_MAP
    #define _NORMALMAP
#endif

#if S_RENDERING_TYPE == 1
    #define _ALPHATEST_ON
#endif
    
    SamplerState MeshTextureSampler < Filter(MIN_MAG_MIP_LINEAR); AddressU(WRAP); AddressV(WRAP); >;

    //
    // Main
    //
    CreateInputTexture2D(InputMainTex, Srgb, 8, "", "", "MToon Color,0/Texture,10/1", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(MainTex)< Channel(RGBA, Box(InputMainTex), Srgb); OutputFormat(BC7); SrgbRead(true); >;

    float4 Color < UiType(Color); Default4(1.0, 1.0, 1.0, 1.0); UiGroup("MToon Color,0/Texture,10/2"); >;

    CreateInputTexture2D(InputShadeTexture, Srgb, 8, "", "", "MToon Color,0/Texture,10/3", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(ShadeTexture)< Channel(RGBA, Box(InputShadeTexture), Srgb); OutputFormat(BC7); SrgbRead(true); >;

    float4 ShadeColor < UiType(Color); Default4(0.97, 0.81, 0.86, 1.0); UiGroup("MToon Color,0/Texture,10/4"); >;

#if S_RENDERING_TYPE == 1 
    float Cutoff < UiType(Slider); Range(0.0, 1.0); Default1(0.5); UiGroup("MToon Color,0/Alpha,20/1"); >;
#endif

    float ShadeToony < UiType(Slider); Range(0.0, 1.0); Default1(0.9); UiGroup("MToon Lighting,1/1"); >;

    // CreateInputTexture2D(InputBumpMap, Linear, 8, "", "", "MToon Lighting,1/2", Default4(0.5, 0.5, 1.0, 0.5));
    // CreateTexture2DWithoutSampler(BumpMap)< Channel(RGBA, Box(InputBumpMap), Linear); OutputFormat(BC7); SrgbRead(false); >;

    float ShadeShift < UiType(Slider); Range(-1.0, 1.0); Default1(0.0); UiGroup("MToon Lighting,11/Advanced Settings,20/1"); >;

    CreateInputTexture2D(InputShadingGradeTexture, Srgb, 8, "", "", "MToon Lighting,1/Advanced Settings,20/2", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(ShadingGradeTexture)< Channel(RGBA, Box(InputShadingGradeTexture), Srgb); OutputFormat(BC7); SrgbRead(true); >;

    float ShadingGradeRate < UiType(Slider); Range(0.0, 1.0); Default1(1.0); UiGroup("MToon Lighting,1/Advanced Settings,20/3"); >;

    float LightColorAttenuation < UiType(Slider); Range(0.0, 1.0); Default1(0.0); UiGroup("MToon Lighting,1/Advanced Settings,20/4"); >;

    float IndirectLightIntensity < UiType(Slider); Range(0.0, 1.0); Default1(0.1); UiGroup("MToon Lighting,1/Advanced Settings,20/5"); >;

    // Texture2D _RimTexture;
    // float4 _RimColor;
    // float _RimLightingMix;
    // float _RimFresnelPower;
    // float _RimLift;
    // Texture2D _SphereAdd;

    float4 EmissionColor < UiType(Color); Default4(0.0, 0.0, 0.0, 1.0); UiGroup("MToon Emission,2/1"); >;
    CreateInputTexture2D(InputEmissionMap, Srgb, 8, "", "", "MToon Emission,2/2", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(EmissionMap)< Channel(RGBA, Box(InputEmissionMap), Srgb); OutputFormat(BC7); SrgbRead(true); >;

    // const
    static const float PI_2 = 6.28318530718;
    static const float EPS_COL = 0.00001;

    class MToonShadingModel : ShadingModel
    {
        float2 mainUv;
        float4 mainTex;
        float alpha;
        float3 worldPos;
        float3 worldNormal;
        float3 worldView;
        float4 lit;
        float4 shade;
        float shadingGrade;
        float lightIntensity;
        float3 lighting;

        //
        // Consumes a material and converts it to the internal shading parameters,
        // That is more easily consumed by the shader.
        //
        // Inherited classes can expand this to whichever shading model they want.
        //
        void Init(const PixelInput i, const Material m)
        {
            // uv
            mainUv = i.vTextureCoords.xy;
            
            // main tex
            mainTex = MainTex.Sample(MeshTextureSampler, mainUv);
        
            // alpha
            alpha = 1;
#ifdef _ALPHATEST_ON
            alpha = Color.a * mainTex.a;
            alpha = (alpha - Cutoff) / max(fwidth(alpha), EPS_COL) + 0.5; // Alpha to Coverage
            clip(alpha - Cutoff);
            alpha = 1.0; // Discarded, otherwise it should be assumed to have full opacity
#endif

            worldPos = i.vPositionWithOffsetWs;

            // normal
#ifdef _NORMALMAP
            worldNormal = m.Normal;
#else
            worldNormal = float3(i.vNormalWs.x, i.vNormalWs.y, i.vNormalWs.z);
#endif

            lit = Color * mainTex;

            shadingGrade = 1.0 - ShadingGradeRate * (1.0 - ShadingGradeTexture.Sample(MeshTextureSampler, mainUv).r);
            shade = ShadeColor * ShadeTexture.Sample(MeshTextureSampler, mainUv);
        }
        
        //
        // Executed for every direct light
        //
        LightShade Direct(const LightData light)
        {
            // Shading output
            LightShade lightShade;

            float dotNL = dot(light.LightDir, worldNormal);

            // Decide albedo color rate from Direct Light
            lightIntensity = dotNL; // [-1, 1]
            lightIntensity = lightIntensity * 0.5 + 0.5; // from [-1, +1] to [0, 1]
            lightIntensity = lightIntensity * light.Visibility * light.Attenuation; // receive shadow
            lightIntensity = lightIntensity * shadingGrade; // darker
            lightIntensity = lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]
            // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]
            float maxIntensityThreshold = lerp(1, ShadeShift, ShadeToony);
            float minIntensityThreshold = ShadeShift;
            lightIntensity = saturate((lightIntensity - minIntensityThreshold) / max(EPS_COL, (maxIntensityThreshold - minIntensityThreshold)));
            
            // Albedo color
            lightShade.Diffuse = lerp(shade.rgb, lit.rgb, lightIntensity);

            float3 lightColor = saturate(light.Visibility * light.Attenuation * light.Color);
            // Direct Light
            lighting = lightColor;
            lighting = lerp(lighting, max(EPS_COL, max(lighting.x, max(lighting.y, lighting.z))), LightColorAttenuation); // color atten
            // base light does not darken.
            lightShade.Diffuse *= lighting;

            // No specular
            lightShade.Specular = 0.0f;

            return lightShade;
        }
        
        //
        // Executed for indirect lighting, combine ambient occlusion, etc.
        //
        LightShade Indirect()
        {
            LightShade lightShade;
            
            float3 toonedGI = 0.5 * (SampleLightProbeVolume(worldPos, float3(0, 1, 0)) + SampleLightProbeVolume(worldPos, float3(0, -1, 0)));
            float3 indirectLighting = lerp(toonedGI, SampleLightProbeVolume(worldPos, worldNormal), IndirectLightIntensity);
            indirectLighting = lerp(indirectLighting, max(EPS_COL, max(indirectLighting.x, max(indirectLighting.y, indirectLighting.z))), LightColorAttenuation); // color atten
            lightShade.Diffuse = indirectLighting * lit.xyz;

            lightShade.Diffuse = min(lightShade.Diffuse, lit.xyz); // comment out if you want to PBR absolutely.

            // No specular
            lightShade.Specular = 0.0f;

            return lightShade;
        }

        float4 PostProcess(float4 vColor)
        {
            // // parametric rim lighting
            // float3 staticRimLighting = 1;
            // float3 mixedRimLighting = lighting + flColor;
            // float3 rimLighting = lerp(staticRimLighting, mixedRimLighting, _RimLightingMix);
            // float3 rim = pow(saturate(1.0 - dot(worldNormal, worldView) + _RimLift), max(_RimFresnelPower, EPS_COL)) * _RimColor.rgb * tex2D(_RimTexture, mainUv).rgb;
            // // i.isOutline -> 0 when outline is disabled, 1 when outline is enabled.
            // vColor += lerp(rim * rimLighting, float3(0, 0, 0), i.isOutline);

            // // additive matcap
            // float3 worldCameraUp = normalize(g_matWorldToView[1].xyz);
            // float3 worldViewUp = normalize(worldCameraUp - worldView * dot(worldView, worldCameraUp));
            // float3 worldViewRight = normalize(cross(worldView, worldViewUp));
            // float2 matcapUv = float2(dot(worldViewRight, worldNormal), dot(worldViewUp, worldNormal)) * 0.5 + 0.5;
            // float3 matcapLighting = tex2D(_SphereAdd, matcapUv);
            // // i.isOutline -> 0 when outline is disabled, 1 when outline is enabled.
            // vColor += lerp(matcapLighting, float3(0, 0, 0), i.isOutline);

            // Emission
            float3 emission = EmissionMap.Sample(MeshTextureSampler, mainUv).rgb * EmissionColor.rgb;
            // i.isOutline -> 0 when outline is disabled, 1 when outline is enabled.
            // vColor.xyz += lerp(emission, float3(0, 0, 0), i.isOutline);
            vColor.xyz += emission;

            // debug
#ifdef MTOON_DEBUG_NORMAL
    #ifdef MTOON_FORWARD_ADD
            return float4(0, 0, 0, 0);
    #else
            return float4(worldNormal * 0.5 + 0.5, alpha);
    #endif
#endif
#ifdef MTOON_DEBUG_LITSHADERATE
    #ifdef MTOON_FORWARD_ADD
            return float4(0, 0, 0, 0);
    #else
            return float4(lightIntensity * lighting, alpha);
    #endif
#endif

            return float4(vColor.xyz, alpha);
        }
    };


    float4 MainPs(PixelInput i) : SV_Target0
    {
        Material m = GatherMaterial(i);
        MToonShadingModel sm;
        return FinalizePixelMaterial(i, m, sm);
    }
}
