//=========================================================================================================================
// Optional
//=========================================================================================================================
HEADER
{
    Description = "Toon Shader with Global Illumination";
    Version = 3.9;
}

//=========================================================================================================================
// Optional
//=========================================================================================================================
FEATURES
{
    Feature(F_USE_NORMAL_MAP, 0..1, "MToon Lighting");
    #include "common/features.hlsl"
    Feature(F_RENDERING_TYPE, 0..1(0="Opaque", 1="Cutout"), "Rendering");
    Feature(F_DEBUGGING_OPTIONS, 0..2(0="None", 1="Normal", 2="LitShadeRate"), "MToon Debug");
}

//=========================================================================================================================
COMMON
{
    #include "common/shared.hlsl"
}

//=========================================================================================================================

struct VertexInput
{
    #include "common/vertexinput.hlsl"
};

//=========================================================================================================================

struct PixelInput
{
    #include "common/pixelinput.hlsl"
};

//=========================================================================================================================

VS
{
    #include "common/vertex.hlsl"
    //
    // Main
    //
    PixelInput MainVs(INSTANCED_SHADER_PARAMS(VertexInput i))
    {
        PixelInput o = ProcessVertex(i);
        // Add your vertex manipulation functions here
        return FinalizeVertex(o);
    }
}

//=========================================================================================================================

PS
{
    //
    // Combos
    //
    StaticCombo(S_USE_NORMAL_MAP, F_USE_NORMAL_MAP, Sys(ALL));
    StaticCombo(S_RENDERING_TYPE, F_RENDERING_TYPE, Sys(ALL));
    StaticCombo(S_DEBUGGING_OPTIONS, F_DEBUGGING_OPTIONS, Sys(ALL));

    //
    // Includes
    //
    #include "common/pixel.hlsl"

    RenderState(CullMode, F_RENDER_BACKFACES ? NONE : DEFAULT);

    #if S_USE_NORMAL_MAP
        #define _NORMALMAP
    #endif

    #if S_RENDERING_TYPE == 1
        #define _ALPHATEST_ON
    #endif

    //
    // Main
    //
    CreateInputTexture2D(InputLitTexture, Srgb, 8, "", "", "MToon Color,1/Texture,1/1", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(LitTexture)< Channel(RGBA, Box(InputLitTexture), Srgb); OutputFormat(BC7); SrgbRead(true); >;
    float4 LitColor < UiType(Color); Default4(1.0, 1.0, 1.0, 1.0); UiGroup("MToon Color,1/Texture,1/2"); >;
    CreateInputTexture2D(InputShadeTexture, Srgb, 8, "", "", "MToon Color,1/Texture,1/3", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(ShadeTexture)< Channel(RGBA, Box(InputShadeTexture), Srgb); OutputFormat(BC7); SrgbRead(true); >;
    float4 ShadeColor < UiType(Color); Default4(0.97, 0.81, 0.86, 1.0); UiGroup("MToon Color,1/Texture,1/4"); >;

    #if S_RENDERING_TYPE == 1 
        float Cutoff < UiType(Slider); Range(0.0, 1.0); Default1(0.5); UiGroup("MToon Color,1/Alpha,2/1"); >;
    #endif

    float ShadingToony < UiType(Slider); Range(0.0, 1.0); Default1(0.9); UiGroup("MToon Lighting,2/1"); >;

    float ShadingShift < UiType(Slider); Range(-1.0, 1.0); Default1(0.0); UiGroup("MToon Lighting,2/Advanced Settings,2/1"); >;
    CreateInputTexture2D(InputShadingGradeTexture, Srgb, 8, "", "", "MToon Lighting,2/Advanced Settings,2/2", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(ShadingGradeTexture)< Channel(RGBA, Box(InputShadingGradeTexture), Srgb); OutputFormat(BC7); SrgbRead(true); >;
    float ShadingGradeRate < UiType(Slider); Range(0.0, 1.0); Default1(1.0); UiGroup("MToon Lighting,2/Advanced Settings,2/3"); >;
    float LightColorAttenuation < UiType(Slider); Range(0.0, 1.0); Default1(0.0); UiGroup("MToon Lighting,2/Advanced Settings,2/4"); >;
    float IndirectLightIntensity < UiType(Slider); Range(0.0, 1.0); Default1(0.0); UiGroup("MToon Lighting,2/Advanced Settings,2/5"); >;

    CreateInputTexture2D(InputEmissionMap, Srgb, 8, "", "", "MToon Emission,3/1", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(EmissionMap)< Channel(RGBA, Box(InputEmissionMap), Srgb); OutputFormat(BC7); SrgbRead(true); >;
    float4 EmissionColor < UiType(Color); Default4(0.0, 0.0, 0.0, 1.0); UiGroup("MToon Emission,3/2"); >;
    CreateInputTexture2D(InputMatCap, Srgb, 8, "", "", "MToon Emission,3/3", Default4(0.0, 0.0, 0.0, 1.0));
    CreateTexture2DWithoutSampler(MatCap)< Channel(RGBA, Box(InputMatCap), Srgb); OutputFormat(BC7); SrgbRead(true); >;

    CreateInputTexture2D(InputRimTexture, Srgb, 8, "", "", "MToon Rim,4/1", Default4(1.0, 1.0, 1.0, 1.0));
    CreateTexture2DWithoutSampler(RimTexture)< Channel(RGBA, Box(InputRimTexture), Srgb); OutputFormat(BC7); SrgbRead(true); >;
    float4 RimColor < UiType(Color); Default4(0.0, 0.0, 0.0, 1.0); UiGroup("MToon Rim,4/2"); >;
    float RimLightingMix < UiType(Slider); Range(0.0, 1.0); Default1(0.0); UiGroup("MToon Rim,4/3"); >;
    float RimFresnelPower < UiType(Slider); Range(0.0, 100.0); Default1(1.0); UiGroup("MToon Rim,4/4"); >;
    float RimLift < UiType(Slider); Range(0.0, 1.0); Default1(0.0); UiGroup("MToon Rim,4/5"); >;

    // const
    static const float PI_2 = 6.28318530718;
    static const float EPS_COL = 0.00001;

    class MToonShadingModel : ShadingModel
    {
        float2 mainUv;
        float4 mainTex;
        float alpha;

        float3 positionWithOffsetWs;
        float3 positionWs;
        float3 viewRayWs;
        float3 normalWs;

        float4 lit;
        float4 shade;
        float shadingGrade;

        float lightIntensity;
        float3 lighting;
        float3 indirectLighting;

        //
        // Consumes a material and converts it to the internal shading parameters,
        // That is more easily consumed by the shader.
        //
        // Inherited classes can expand this to whichever shading model they want.
        //
        void Init(const PixelInput i, const Material m)
        {
            // uv
            mainUv = i.vTextureCoords.xy;
            
            // main tex
            mainTex = Tex2DS(LitTexture, TextureFiltering, mainUv);
        
            // alpha
            alpha = 1;
            #ifdef _ALPHATEST_ON
                alpha = LitColor.a * mainTex.a;
                alpha = (alpha - Cutoff) / max(fwidth(alpha), EPS_COL) + 0.5; // Alpha to Coverage
                clip(alpha - Cutoff);
                alpha = 1.0; // Discarded, otherwise it should be assumed to have full opacity
            #endif

            positionWithOffsetWs = i.vPositionWithOffsetWs;
            positionWs = positionWithOffsetWs + g_vCameraPositionWs;

            // View ray in World Space
            viewRayWs = CalculatePositionToCameraDirWs(positionWs);

            // normal
            #ifdef _NORMALMAP
                normalWs = m.Normal;
            #else
                normalWs = float3(i.vNormalWs.x, i.vNormalWs.y, i.vNormalWs.z);
            #endif

            lit = LitColor * mainTex;
            shade = ShadeColor * Tex2DS(ShadeTexture, TextureFiltering, mainUv);
            shadingGrade = 1.0 - ShadingGradeRate * (1.0 - Tex2DS(ShadingGradeTexture, TextureFiltering, mainUv).r);
        }

        //
        // Executed for every direct light
        //
        LightShade Direct(const LightData light)
        {
            // Shading output
            LightShade lightShade;

            float dotNL = dot(light.LightDir, normalWs);

            // Decide albedo color rate from Direct Light
            lightIntensity = dotNL; // [-1, +1]
            lightIntensity = lightIntensity * 0.5 + 0.5; // from [-1, +1] to [0, 1]
            lightIntensity = lightIntensity * light.Visibility * light.Attenuation; // receive shadow
            lightIntensity = lightIntensity * shadingGrade; // darker
            lightIntensity = lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]
            // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]
            float maxIntensityThreshold = lerp(1, ShadingShift, ShadingToony);
            float minIntensityThreshold = ShadingShift;
            lightIntensity = saturate((lightIntensity - minIntensityThreshold) / max(EPS_COL, (maxIntensityThreshold - minIntensityThreshold)));
            
            // Albedo color
            lightShade.Diffuse = lerp(shade.rgb, lit.rgb, lightIntensity);

            float3 lightColor = saturate(light.Visibility * light.Attenuation * light.Color);
            // Direct Light
            lighting = lightColor;
            lighting = lerp(lighting, max(EPS_COL, max(lighting.x, max(lighting.y, lighting.z))), LightColorAttenuation); // color atten
            // base light does not darken.
            lightShade.Diffuse *= lighting;

            // No specular
            lightShade.Specular = 0.0f;

            return lightShade;
        }

        //
        // Executed for indirect lighting, combine ambient occlusion, etc.
        //
        LightShade Indirect()
        {
            LightShade lightShade;
            
            float3 toonedGI = 0.5 * (SampleLightProbeVolume(positionWs, float3(0, 1, 0)) + SampleLightProbeVolume(positionWs, float3(0, -1, 0)));
            indirectLighting = lerp(toonedGI, SampleLightProbeVolume(positionWs, normalWs), IndirectLightIntensity);
            indirectLighting = lerp(indirectLighting, max(EPS_COL, max(indirectLighting.x, max(indirectLighting.y, indirectLighting.z))), LightColorAttenuation); // color atten
            lightShade.Diffuse = indirectLighting * lit.rgb;

            lightShade.Diffuse = min(lightShade.Diffuse, lit.rgb); // comment out if you want to PBR absolutely.

            // No specular
            lightShade.Specular = 0.0f;

            return lightShade;
        }

        float4 PostProcess(float4 vColor)
        {
            // parametric rim lighting
            float3 staticRimLighting = 1;
            float3 mixedRimLighting = lighting + indirectLighting;
            float3 rimLighting = lerp(staticRimLighting, mixedRimLighting, RimLightingMix);
            float3 rim = pow(saturate(1.0 - dot(normalWs, viewRayWs) + RimLift), max(RimFresnelPower, EPS_COL)) * RimColor.rgb * Tex2DS(RimTexture, TextureFiltering, mainUv).rgb;
            vColor.rgb += rim * rimLighting;

            // additive matcap
            float3 worldCameraUp = normalize(g_vCameraUpDirWs);
            float3 worldViewUp = normalize(worldCameraUp - viewRayWs * dot(viewRayWs, worldCameraUp));
            float3 worldViewRight = normalize(cross(viewRayWs, worldViewUp));
            float2 matcapUv = float2(dot(worldViewRight, normalWs), dot(worldViewUp, normalWs)) * 0.5 + 0.5;
            float3 matcapLighting = Tex2DS(MatCap, TextureFiltering, matcapUv).rgb;
            vColor.rgb += matcapLighting;

            // Emission
            float3 emission = Tex2DS(EmissionMap, TextureFiltering, mainUv).rgb * EmissionColor.rgb;
            vColor.rgb += emission;

            // debug
            #if S_DEBUGGING_OPTIONS == 1
                return float4(normalWs * 0.5 + 0.5, alpha);
            #elif S_DEBUGGING_OPTIONS == 2
                return float4(lightIntensity * lighting, alpha);
            #endif

            return float4(vColor.rgb, alpha);
        }
    };

    float4 MainPs(PixelInput i) : SV_Target0
    {
        Material m = GatherMaterial(i);
        MToonShadingModel sm;
        return FinalizePixelMaterial(i, m, sm);
    }
}
